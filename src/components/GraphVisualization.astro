---
import { getCollection } from 'astro:content';
import {getLocale} from "astro-i18n-aut";

const currentLang = getLocale(Astro.url);

const allTopics: any[] = await getCollection('topics', ({ data }) => {
    return !data.draft && data.lang === currentLang;
    });

const t = {
    en: {
    resetZoom: 'Reset Zoom',
    centerGraph: 'Center Graph',
    showLinks: 'Show Links:',
    showTagLinks: 'Show Tag Links:',
    allCategories: 'All Categories',
    cognition: '🧠 Cognition',
    society: '🏛️ Society',
    technology: '⚙️ Technology',
    philosophy: '💭 Philosophy',
    meta: '📋 META',
    legend: 'Legend:',
    level12: 'Level 1-2',
    level3: 'Level 3',
    level45: 'Level 4-5',
    nodeSize: 'Node size = number of connections',
    connections: 'Connections',
    level: 'Level'
    },
    ru: {
    resetZoom: 'Сбросить масштаб',
    centerGraph: 'Центрировать',
    showLinks: 'Показать связи:',
    showTagLinks: 'Показать связи по тегам:',
    allCategories: 'Все категории',
    cognition: '🧠 Познание',
    society: '🏛️ Общество',
    technology: '⚙️ Технологии',
    philosophy: '💭 Философия',
    meta: '📋 META',
    legend: 'Легенда:',
    level12: 'Уровень 1-2',
    level3: 'Уровень 3',
    level45: 'Уровень 4-5',
    nodeSize: 'Размер узла = количество связей',
    connections: 'Связей',
    level: 'Уровень'
    }
    };

const translations = t[currentLang] || t.ru;

// Create nodes and links for D3.js
const nodes = allTopics.map(topic => ({
    id: topic.slug,
    title: topic.data.title,
    level: topic.data.level,
    category: topic.data.category || 'other',
    tags: topic.data.tags || [],
    url: `/topics/${topic.slug}`,
    }));

const links = [];
const tagLinks = [];

// Regular related links
allTopics.forEach(topic => {
    if (topic.data.related) {
    topic.data.related.forEach(relatedPath => {
    const relatedSlug = relatedPath.replace('/topics/', '');
    const targetExists = nodes.find(n => n.id === relatedSlug);
    if (targetExists) {
        links.push({
            source: topic.slug,
            target: relatedSlug,
            type: 'related'
            });
        }
    });
    }
    });

// Tag-based links
allTopics.forEach((topic, i) => {
    allTopics.forEach((otherTopic, j) => {
        if (i >= j) return; // Avoid duplicates

        const commonTags = topic.data.tags?.filter(tag =>
            otherTopic.data.tags?.includes(tag)
            ) || [];

        if (commonTags.length > 0) {
            tagLinks.push({
                source: topic.slug,
                target: otherTopic.slug,
                type: 'tag',
                commonTags: commonTags
                });
            }
        });
    });

const graphData = { nodes, links, tagLinks };
---

<style>
    /* CSS Variables */
    :root {
        --color-base-100: #ffffff;
        --color-base-200: #f3f4f6;
        --color-base-300: #e5e7eb;
        --color-base-content-50: rgba(55, 65, 81, 0.5);
        --color-base-content-70: rgba(55, 65, 81, 0.7);
        --color-primary: #3b82f6;
        --color-success: #10b981;
        --color-warning: #f59e0b;
        --color-error: #ef4444;
        --border-radius: 0.5rem;
        --border-radius-sm: 0.25rem;
        --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    .graph-container {
        user-select: none;
    }

    .controls {
        margin-bottom: 1rem;
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
    }

    .control-btn {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        border: 1px solid var(--base-content);
        background-color: var(--base-200);
        color: var(--base-content);
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        transition: all 0.2s ease;
    }

    .control-btn:hover {
        background-color: var(--base-200);
        border-color: var(--color-primary);
        color: var(--color-primary);
    }

    .form-control {
        display: flex;
        align-items: center;
    }

    .label {
        display: flex;
        align-items: center;
        cursor: pointer;
        font-size: 0.875rem;
        color: var(--color-base-content);
    }

    .label-text {
        margin-right: 0.5rem;
    }

    .toggle {
        appearance: none;
        width: 3rem;
        height: 1.5rem;
        background-color: var(--base-200);
        border-radius: 1rem;
        position: relative;
        cursor: pointer;
        transition: background-color 0.2s ease;
    }

    .toggle:checked {
        background: var(--color-primary);
    }

    .toggle::before {
        content: '';
        position: absolute;
        width: 1.25rem;
        height: 1.25rem;
        background: white;
        border-radius: 50%;
        top: 0.125rem;
        left: 0.125rem;
        transition: transform 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .toggle:checked::before {
        transform: translateX(1.5rem);
    }

    .select {
        padding: 0.375rem 0.75rem;
        font-size: 0.875rem;
        border: 1px solid var(--base-content);
        background-color: var(--base-200);
        color: var(--color-base-content);
        border-radius: var(--border-radius-sm);
        cursor: pointer;
        min-width: 150px;
    }

    .select:focus {
        outline: none;
        border-color: var(--color-primary);
        box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
    }

    .tooltip-container {
        position: absolute;
        z-index: 1000;
        pointer-events: none;
    }

    .tooltip-content {
        background-color: var(--base-200);
        border: 1px solid var(--base-content);
        border-radius: var(--border-radius);
        padding: 0.75rem;
        box-shadow: var(--shadow-lg);
        max-width: 20rem;
    }

    .tooltip-title {
        font-weight: bold;
        font-size: 0.875rem;
        margin-bottom: 0.25rem;
    }

    .tooltip-category {
        font-size: 0.75rem;
        color: var(--base-content);
        margin-bottom: 0.25rem;
    }

    .tooltip-connections {
        font-size: 0.75rem;
        color: var(--base-content);
        margin-bottom: 0.5rem;
    }

    .tooltip-tags {
        display: flex;
        flex-wrap: wrap;
        gap: 0.25rem;
    }

    .graph-svg-container {
        width: 100%;
        height: 600px;
        border: 1px solid var(--base-content);
        border-radius: var(--border-radius);
        background-color: var(--base-200);
        overflow: hidden;
    }

    #knowledge-graph {
        width: 100%;
        height: 100%;
        background: transparent;
    }

    .legend {
        margin-top: 1rem;
    }

    .legend-title {
        font-weight: bold;
        margin-bottom: 0.5rem;
    }

    .legend-items {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        font-size: 0.875rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .legend-color {
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
    }

    .legend-color.success {
        background: var(--color-success);
    }

    .legend-color.warning {
        background: var(--color-warning);
    }

    .legend-color.error {
        background: var(--color-error);
    }

    .badge {
        font-size: 0.625rem;
        padding: 0.125rem 0.25rem;
        border-radius: var(--border-radius-sm);
        font-weight: 500;
    }

    .badge-xs {
        font-size: 0.625rem;
        padding: 0.125rem 0.25rem;
    }

    .badge-outline {
        background: transparent;
        border: 1px solid var(--base-content);
        color: var(--color-base-content);
    }

    .hidden {
        display: none;
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .graph-svg-container {
            height: 400px;
        }

        .controls {
            flex-direction: column;
            align-items: stretch;
        }

        .controls > * {
            width: 100%;
        }

        .select {
            min-width: auto;
        }
    }
</style>

<div class="graph-container">
    <div class="controls">
        <button id="reset-zoom" class="control-btn">{translations.resetZoom}</button>
        <button id="center-graph" class="control-btn">{translations.centerGraph}</button>

        <div class="form-control">
            <label class="label">
                <span class="label-text">{translations.showLinks}</span>
                <input type="checkbox" id="show-links" class="toggle" checked />
            </label>
        </div>

        <div class="form-control">
            <label class="label">
                <span class="label-text">{translations.showTagLinks}</span>
                <input type="checkbox" id="show-tag-links" class="toggle" />
            </label>
        </div>

        <select id="category-filter" class="select">
            <option value="">{translations.allCategories}</option>
            <option value="cognition">{translations.cognition}</option>
            <option value="society">{translations.society}</option>
            <option value="technology">{translations.technology}</option>
            <option value="philosophy">{translations.philosophy}</option>
            <option value="meta">{translations.meta}</option>
        </select>
    </div>

    <div id="graph-tooltip" class="tooltip-container hidden">
        <div class="tooltip-content">
            <h4 class="tooltip-title" id="tooltip-title"></h4>
            <p class="tooltip-category" id="tooltip-category"></p>
            <p class="tooltip-connections" id="tooltip-connections"></p>
            <div class="tooltip-tags" id="tooltip-tags"></div>
        </div>
    </div>

    <div class="graph-svg-container">
        <svg id="knowledge-graph"></svg>
    </div>

    <div class="legend">
        <div class="legend-items">
            <div class="legend-item">
                <span style="margin-left: 1rem;">{translations.nodeSize}</span>
            </div>
        </div>
    </div>
</div>

<script define:vars={{ graphData, translations }}>
    // D3.js implementation for knowledge graph
    import('https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js').then(() => {
        const container = d3.select('.graph-svg-container');
        const svg = d3.select('#knowledge-graph');
        const tooltip = d3.select('#graph-tooltip');

        const width = 800;
        const height = 600;

        svg.attr('viewBox', [0, 0, width, height]);

        const categoryColors = {
            cognition: '#0ea5e9',
            society: '#10b981',
            technology: '#f59e0b',
            philosophy: '#8b5cf6',
            meta: '#ef4444',
            other: '#64748b'
        };

        function calculateConnectionCounts(nodes, links, tagLinks, showTagLinks) {
            const connectionCount = {};

            nodes.forEach(node => {
                connectionCount[node.id] = 0;
            });

            links.forEach(link => {
                const sourceId = typeof link.source === 'string' ? link.source : link.source.id;
                const targetId = typeof link.target === 'string' ? link.target : link.target.id;

                if (connectionCount[sourceId] !== undefined) {
                    connectionCount[sourceId]++;
                }
                if (connectionCount[targetId] !== undefined) {
                    connectionCount[targetId]++;
                }
            });

            if (showTagLinks) {
                tagLinks.forEach(link => {
                    const sourceId = typeof link.source === 'string' ? link.source : link.source.id;
                    const targetId = typeof link.target === 'string' ? link.target : link.target.id;

                    if (connectionCount[sourceId] !== undefined) {
                        connectionCount[sourceId]++;
                    }
                    if (connectionCount[targetId] !== undefined) {
                        connectionCount[targetId]++;
                    }
                });
            }

            return connectionCount;
        }

        const getRadius = (connectionCount) => {
            return Math.max(5, 5 + (connectionCount * 0.5));
        };

        const getLevelColor = (level, category) => {
            const baseColor = categoryColors[category] || categoryColors.other;
            const opacity = Math.max(0.4, 1 - (level - 1) * 0.15);
            return d3.color(baseColor).copy({opacity});
        };

        let currentData = JSON.parse(JSON.stringify(graphData));
        let showTagLinks = false;
        let showRegularLinks = true;

        function getCombinedLinks() {
            let combinedLinks = [];

            if (showRegularLinks) {
                combinedLinks = combinedLinks.concat(currentData.links);
            }

            if (showTagLinks) {
                combinedLinks = combinedLinks.concat(currentData.tagLinks);
            }

            return combinedLinks;
        }

        function initializeGraph() {
            svg.selectAll('*').remove();

            // NEW: Add arrowhead marker definitions
            svg.append('defs').selectAll('marker')
                .data(['related', 'tag']) // One for each link type
                .join('marker')
                .attr('id', d => `arrowhead-${d}`)
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8) // Position of the marker along the line
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', d => d === 'tag' ? '#ff6b6b' : '#586f91'); // Match link colors


            const combinedLinks = getCombinedLinks();

            const connectionCounts = calculateConnectionCounts(
                currentData.nodes,
                currentData.links,
                currentData.tagLinks,
                showTagLinks
            );

            currentData.nodes.forEach(node => {
                node.connectionCount = connectionCounts[node.id] || 0;
            });

            const simulation = d3.forceSimulation(currentData.nodes)
                .force('link', d3.forceLink(combinedLinks).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getRadius(d.connectionCount) + 2));

            // Links
            const link = svg.append('g')
                .selectAll('line')
                .data(combinedLinks)
                .join('line')
                .attr('stroke', d => d.type === 'tag' ? '#ff6b6b' : '#586f91')
                .attr('stroke-opacity', d => d.type === 'tag' ? 0.4 : 0.3)
                .attr('stroke-width', d => d.type === 'tag' ? 1.5 : 1)
                .attr('stroke-dasharray', d => d.type === 'tag' ? '3,3' : 'none')
                // NEW: Apply the correct marker to each link
                .attr('marker-end', d => `url(#arrowhead-${d.type})`);


            // Nodes
            const node = svg.append('g')
                .selectAll('circle')
                .data(currentData.nodes)
                .join('circle')
                .attr('r', d => getRadius(d.connectionCount))
                .attr('fill', d => getLevelColor(d.level, d.category))
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .style('cursor', 'pointer');

            // Labels
            const labels = svg.append('g')
                .selectAll('text')
                .data(currentData.nodes)
                .join('text')
                .text(d => d.title.length > 20 ? d.title.substring(0, 20) + '...' : d.title)
                .attr('font-size', 10)
                .attr('font-family', 'Inter, sans-serif')
                .attr('text-anchor', 'middle')
                .attr('dy', d => getRadius(d.connectionCount) + 15)
                .attr('fill', 'currentColor')
                .style('pointer-events', 'none');

            // Drag behavior
            const drag = d3.drag()
                .on('start', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on('end', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                    d.fx = null;
                    d.fy = null;
                });

            node.call(drag);

            // Hover and click events
            node
                .on('mouseover', (event, d) => {
                    showTooltip(event, d);
                    highlightConnected(d.id, true);
                })
                .on('mouseout', (event, d) => {
                    hideTooltip();
                    highlightConnected(d.id, false);
                })
                .on('click', (event, d) => {
                    window.open(d.url, '_blank');
                });

            // Zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.5, 3])
                .on('zoom', (event) => {
                    svg.selectAll('g').attr('transform', event.transform);
                });

            svg.call(zoom);

            // Controls
            d3.select('#reset-zoom').on('click', () => {
                svg.transition().duration(750).call(
                    zoom.transform,
                    d3.zoomIdentity
                );
            });

            d3.select('#center-graph').on('click', () => {
                simulation.alpha(1).restart();
            });

            d3.select('#show-links').on('change', function() {
                showRegularLinks = this.checked;
                initializeGraph();
            });

            d3.select('#show-tag-links').on('change', function() {
                showTagLinks = this.checked;
                initializeGraph();
            });

            d3.select('#category-filter').on('change', function() {
                filterByCategory(this.value);
            });

            // Update positions
            simulation.on('tick', () => {
                // MODIFIED: Adjust link endpoints to stop at the node's edge
                link.each(function(d) {
                    const targetNode = d.target;
                    const sourceNode = d.source;

                    const targetRadius = getRadius(targetNode.connectionCount) + 2; // Add node stroke width

                    const dx = targetNode.x - sourceNode.x;
                    const dy = targetNode.y - sourceNode.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    // Avoid division by zero
                    if (dist === 0) return;

                    const newTargetX = targetNode.x - (dx / dist) * targetRadius;
                    const newTargetY = targetNode.y - (dy / dist) * targetRadius;

                    d3.select(this)
                        .attr('x1', sourceNode.x)
                        .attr('y1', sourceNode.y)
                        .attr('x2', newTargetX)
                        .attr('y2', newTargetY);
                });

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                labels
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });
        }

        function showTooltip(event, d) {
            const tooltipTitle = document.getElementById('tooltip-title');
            const tooltipCategory = document.getElementById('tooltip-category');
            const tooltipConnections = document.getElementById('tooltip-connections');
            const tooltipTags = document.getElementById('tooltip-tags');

            tooltipTitle.textContent = d.title;
            tooltipCategory.textContent = `${d.category || 'other'} • ${translations.level} ${d.level}`;
            tooltipConnections.textContent = `${translations.connections}: ${d.connectionCount}`;

            tooltipTags.innerHTML = '';
            (d.tags || []).slice(0, 4).forEach(tag => {
                const span = document.createElement('span');
                span.className = 'badge badge-xs badge-outline';
                span.textContent = tag;
                tooltipTags.appendChild(span);
            });

            tooltip
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .classed('hidden', false);
        }

        function hideTooltip() {
            tooltip.classed('hidden', true);
        }

        // MODIFIED: This function now highlights only OUTGOING links
        function highlightConnected(nodeId, highlight) {
            const combinedLinks = getCombinedLinks();

            // Node highlighting logic remains the same (show neighbors)
            if (highlight) {
                const connectedIds = new Set([nodeId]);
                combinedLinks.forEach(link => {
                    const sourceId = typeof link.source === 'string' ? link.source : link.source.id;
                    const targetId = typeof link.target === 'string' ? link.target : link.target.id;

                    if (sourceId === nodeId) connectedIds.add(targetId);
                    if (targetId === nodeId) connectedIds.add(sourceId);
                });

                svg.selectAll('circle')
                    .attr('opacity', d => (connectedIds.has(d.id) ? 1 : 0.3));
            } else {
                svg.selectAll('circle').attr('opacity', 1);
            }

            // Link highlighting logic is changed
            svg.selectAll('line')
                .attr('stroke-opacity', d => {
                    if (!highlight) {
                        return d.type === 'tag' ? 0.4 : 0.3; // Reset to default opacity
                    }

                    const sourceId = typeof d.source === 'string' ? d.source : d.source.id;

                    // Highlight only links originating from the hovered node
                    return (sourceId === nodeId) ? 1 : 0.1;
                });
        }


        function filterByCategory(category) {
            if (category === '') {
                currentData = JSON.parse(JSON.stringify(graphData));
            } else {
                const filteredNodes = graphData.nodes.filter(n => n.category === category);
                const nodeIds = new Set(filteredNodes.map(n => n.id));

                currentData = {
                    nodes: filteredNodes,
                    links: graphData.links.filter(l => nodeIds.has(l.source) && nodeIds.has(l.target)),
                    tagLinks: graphData.tagLinks.filter(l => nodeIds.has(l.source) && nodeIds.has(l.target))
                };
            }
            initializeGraph();
        }

        // Initialize the graph
        initializeGraph();
    });
</script>
